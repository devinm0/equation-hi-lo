<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <meta charset="UTF-8" />
  <title>Equation Hi Lo</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
    <!-- Choice Modal -->
    <div id="choiceModal" class="modal-overlay hidden">
        <div class="modal">
        <!-- <h2>Select Your Option</h2> -->
        <div class="options">
            <div class="option" data-choice="low">
            <div class="low-symbol">1</div>
            <p>Low</p>
            </div>
            <div class="option" data-choice="high">
            <div class="high-symbol">20</div>
            <p>High</p>
            </div>
        </div>
        <div class="buttons">
            <button id="confirmChoice">Confirm</button>
            <!-- <button id="cancelChoice">Cancel</button> -->
        </div>
        </div>
    </div>

    <!-- <div id="handResultsModal" class="modal-overlay hidden">
        <div class="modal">
            <div class="buttons">
            </div>
        </div>
    </div> -->

    <div id="notificationWrapper">
        <div id="notificationDiv" style="display: none;"></div>
    </div>

    <div id="uiContainer">
        <div id="lobbyTitleContainer">Equation Hi Lo</div>
        <div id="lobbyPlayerListContainer"></div>
        <div id="nameContainer">
            <input type="text" id="nameInput" placeholder="Enter your name" pattern="^[a-zA-Z0-9]{1,16}$" required title="Username consists of 1-16 letters or numbers"/>
            <p id="error" style="color: red;"></p>
            <button id="joinButton">Join</button>
        </div>
        <button class="button" id="startButton" style="display:none;" disabled>Start Game</button>
    </div>

    <div id="potDiv" style="text-align: center; font-weight: bold; margin-bottom: 10px;"></div>

    <div id="chipStacksContainer" class="chip-stacks-container"></div>

    <div id="bettingControls" style="display:none;">
        <div id="chipStagingContainer" style="text-align:center; font-weight: bold; color: white;"><span id="betAmountLabel">0</span></div>
        <div id="betContainer">
            <button class="button" id="foldButton">Fold</button>
            <input type="range" min="0" max="1000" value="0" id="betSlider">
            <button class="button" id="callRaiseButton">Call</button>
            <button class="button" id="allInButton">All In</button>
        </div>
    </div>

    <button id="confirmResults" class="hidden">Next Hand</button>

    <button class="button" id="leaveButton" style="display:none;">Leave Game</button>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
    <script type="module">
    
    import { NumberCards, OperatorCards, Suits } from './enums.js';

    // SECTION Countdown timer code. //
    const totalDuration = 90 * 1000; // 60 seconds
    const display = document.getElementById('notificationDiv');

    let startTime = Date.now();
    let endTime = startTime + totalDuration;

    function updateTimer() {
        const now = Date.now();
        const remaining = Math.max(0, Math.floor((endTime - now) / 1000));
        display.textContent = remaining;

        if (remaining > 0) {
            requestAnimationFrame(updateTimer); // More accurate and smoother
        }
    }
    // END SECTION Countdown timer code. //

    const socket = new WebSocket(`ws://172.20.10.5:3000`);
    const handDivs = {}; // list of divs, one for each player
    const lobbyPlayerDivs = {}; // list of nametags basically, for game lobby. one per player

    const EXPIRATION_TIME = 1000 * 60 * 60 * 24;  // 1 day in milliseconds
    const USER_ID_KEY = 'userId';
    const USER_NAME_KEY = 'userName';
    const USER_COLOR_KEY = 'userColor';
    const TIMESTAMP_KEY = 'timestamp';

    let myId = localStorage.getItem(USER_ID_KEY);
    let myColor = localStorage.getItem(USER_COLOR_KEY);
    let myName = localStorage.getItem(USER_NAME_KEY);
    let timestamp = localStorage.getItem(TIMESTAMP_KEY);
    let myHand = null; // TODO this needs to be a serialized object
    let sortable = null; // allows for rearranging our hand to form the equation
    let numPlayersJoined = 0;

    socket.addEventListener("message", (event) => {
      const msg = JSON.parse(event.data);

      if (msg.type === "init") {
        const now = Date.now();

        console.log("myId is: ", myId, " server message is: ", event.data, " So if the userIds don't match, it means we've rejoined. Discarding the server generated id.");
        if (!myId || !timestamp || now - timestamp > EXPIRATION_TIME) { // nothing in localStorage, means we are new, fill in with server generated user data
            myId = msg.id;
            myColor = msg.color;
            localStorage.setItem(USER_ID_KEY, myId);
            localStorage.setItem(USER_COLOR_KEY, myColor);
            localStorage.setItem(TIMESTAMP_KEY, now);
        } else { // items exist in localStorage = we exist = page refreshed
            // send rejoin socket message
            const data = {
                type: "rejoin",
                id: myId,
                color: myColor,
                username: myName
            };
            socket.send(JSON.stringify(data));

            // if we rejoin after joining, but before the game starts, we are still in the lobby.
            // don't show name input controls in that case. We've already joined.
            document.getElementById("nameContainer").style.display = "none";
        }

        if (msg.hostId === myId) { 
            const button = document.getElementById("startButton")
            button.style.display = "block";
            button.disabled = true; // only enable it once the host joins
        }
      } else if (msg.type === "game-started") {
        const btn = document.getElementById("startButton");
        btn.parentNode.removeChild(btn);
        // document.getElementById("leaveButton").style.display = "block";
        document.getElementById("lobbyPlayerListContainer").remove();
        document.getElementById("lobbyTitleContainer").remove();
        alert("The game has started!");
      } else if (msg.type === "reject") {
        alert("At least 2 players must join before starting the game.");
      } else if (msg.type === "begin-hand") {
        alert("Beginning hand " + (msg.handNumber + 1));
      } else if (msg.type === "deal") {
        console.log(msg);
        if (msg.id === myId) {
            myHand = msg.hand;
        }        
        drawHand(msg.id, msg.username, msg.hand, msg.multiplicationCardDealt);
    
        if (msg.chipCount !== undefined) {
            // this should be msg.id I guess. originally I was only using the deal message for myself
            updateChipStack(msg.chipCount, document.getElementById("chipStacksContainer-" + msg.id));
        }
        // TODO 5/20
        // need the same bool to only do this with alert.
        const highlightedCards = document.querySelectorAll('.card-highlighted');
        highlightedCards.forEach(card => {
            // have a guard clause here but might be better to KNOW that I'll only call this once
            if (!card.classList.contains('listener-added')) {
                card.addEventListener('click', function() {
                    console.log('sending a discard message ');
                    console.log(this);
                    const data = {
                        type: "discard",
                        id: myId,
                        value: this.children[0].dataset.value,
                        color: myColor,
                        username: myName
                    };
                    socket.send(JSON.stringify(data));
                    // remove the highlight from ALL cards
                    document.querySelectorAll('.card-highlighted').forEach(card => {
                        card.classList.remove("card-highlighted");// only do this once server confirms??
                    });
                });

                card.classList.add('listener-added');
            }
        });
      } else if (msg.type === "player-joined") {
        drawPlayer(msg.id, msg.color, msg.username, msg.hostId);

        numPlayersJoined += 1;

        if (numPlayersJoined >= 2 && msg.hostId === myId) {
            // we are the Host, and there's at least one other player, so game can be started
            document.getElementById("startButton").disabled = false;            
        }
      } else if (msg.type === "player-discarded") {
        alert(msg.username + " discarded their " + msg.value + " card.");
      } else if (msg.type === "first-round-betting-commenced") {
        console.log("First round betting commenced.");
        alert("First round betting has commenced.");
      } else if (msg.type === "second-round-betting-commenced") {
          alert("Second round betting has commenced.");
      } else if (msg.type === "player-folded") {
            alert(msg.username + " folded.");
            drawHand(msg.id, msg.username, msg.hand, false, true);
      } else if (msg.type === "player-formed-equation") {
        // no new cards are dealt, so we need this special message to make everyone redraw the reordered hands 
            drawHand(msg.id, msg.username, msg.hand, false, false); 
      } else if (msg.type === "bet-placed") {
        console.log("socket message bet-placed");
            alert(msg.username + " bet " + msg.betAmount);
            updateChipStack(msg.chipCount, document.getElementById("chipStacksContainer-" + msg.id));

            // update pot
            document.getElementById("potDiv").textContent = "Pot";
            updateChipStack(msg.pot, document.getElementById("chipStacksContainer")); //should rename it to potStacksContainer
      } else if (msg.type === "next-turn") {
        console.log("socket message next-turn");
        // document.getElementById("potDiv").textContent = "Pot: " + msg.pot;
        // updateChipStack(msg.pot, document.getElementById("chipStacksContainer"));
        // console.log(msg.currentTurnPlayerId, myId, msg.toCall);

        if (msg.currentTurnPlayerId === myId) { // bad practice. trusting the client to do this.
            setupBettingControls(msg.toCall, msg.maxBet, msg.playerChipCount);
            console.log("calling hideNotificationDiv from here");
            hideNotificationDiv();
        } else {
            notifyThatAnotherPlayerIsBetting(msg.username);
        }

        // highlight only the betting person's hand
        document.querySelectorAll(".handLabel").forEach(el => {
            el.style.color = "";
        });
        let handLabel = document.getElementById("handLabel-" + msg.currentTurnPlayerId)
        handLabel.style.color = "yellow";
        // chips move from your stack to a staging stack
      } else if (msg.type === "end-betting-round") {
        // remove highlights from who is betting
        document.querySelectorAll(".handLabel").forEach(el => {
            el.style.backgroundColor = "";
        });

        console.log("socket message end-betting-round");
        if (msg.round === 'first'){
            alert('First betting round complete. Dealing last open card');
        } else if (msg.round === 'second') {
            alert('Second betting round complete.');
        }
      } else if (msg.type === "commence-equation-forming") {
        console.log("socket message commence-equation-forming");
            alert('90 seconds! Drag cards to get close to 1 or 20.');
            beginCountdownNotification();
            sortable.option("disabled", false)

      } else if (msg.type === "players-are-equation-forming") {
            alert('Other players are forming their equations.');
            beginCountdownNotification();

      } else if (msg.type === "end-equation-forming") {
            console.log("socket message end-equation-forming");
            hideNotificationDiv(); // do we call this actually? rename to resetAndHideNotificationDiv?
            alert('Time is up!');

            sortable.option("disabled", true)

            let equationResult;
            try {
                equationResult = applyOps(handDivs[myId].querySelectorAll('.card'));
            } catch (e) {
                alert("You were unable to form an equation. You fold automatically.");
                socket.send(JSON.stringify({ type: "folded", userId: myId }));
            }
            console.log(Array.from(handDivs[myId].querySelectorAll('.card')).map(card => card.dataset.id));
            const data = {
                type: "equation-result",
                userId: myId,
                username: myName,
                result: equationResult,
                order: Array.from(handDivs[myId].querySelectorAll('.card')).map(card => card.dataset.id)
            };
            socket.send(JSON.stringify(data));
      } else if (msg.type === "hi-lo-selection") {
        alert("Select Hi, Lo, or Swing betting.");

        openChoiceModal(choices => {
            if (choices) {
                const data = {
                    type: "hi-lo-selected",
                    userId: myId,
                    username: myName,
                    choices: choices
                };
                console.log(data);
                socket.send(JSON.stringify(data));

                console.log('Player chose:', choices); // e.g., ["low", "high"]
            } else {
                console.log('Player canceled');
            }
            });
      } else if (msg.type === "round-result") {
        alert(msg.message);
        // reset  pot
        document.getElementById("potDiv").textContent = "Pot";
        updateChipStack(0, document.getElementById("chipStacksContainer")); //should rename it to potStacksContainer
        
        if (! msg.becauseAllButOneFolded) {
            displayHandResults(msg); // in the case of everyone but one folding, we don't need to show results
            // a message saying the whole pot went to the last person by default is sufficient.
        }
    } else if (msg.type === "chip-distribution") {
        console.log("socket message chip-distribution");

        updateChipStack(msg.chipCount, document.getElementById("chipStacksContainer-" + msg.id));
        // do I need code here to actually keep track of MY chip count? or server does it
      } else if (msg.type === "kicked") {
        if (msg.userId === myId) {
            alert("No more chips! You're out. Better luck next time!");
        } else {
            //TODO redraw hand to be out (red and strikethrough)
            alert(msg.username + " has no more chips and is out of the game.");
        }
      }
    });

    document.getElementById("joinButton").addEventListener("click", () => {
        if (myName === null || myName === undefined) { // server prevents username being set twice
            const nameInput = document.getElementById("nameInput");
            const error = document.getElementById("error");

            console.log(error);
            const regex = /^[a-zA-Z0-9]{1,16}$/;

            if (!regex.test(nameInput.value)) {
                console.log("Must be 1-16 alphanumeric characters.");
                error.textContent = "Must be 1-16 alphanumeric characters.";
            } else {
                console.log("Name input value succeeds regex validation.");

                error.textContent = "";
            
                myName = nameInput.value; //.trim();
                localStorage.setItem('userName', myName);

                const data = {
                    type: "join",
                    color: myColor,
                    userId: myId,
                    username: myName
                };
                socket.send(JSON.stringify(data));

                document.getElementById("nameContainer").style.display = "none";
            }
        }

    });

    document.getElementById("startButton").addEventListener("click", () => {
        socket.send(JSON.stringify({ type: "start", id: myId }));
    });

    document.getElementById('leaveButton').addEventListener('click', () => {
      localStorage.removeItem(USER_ID_KEY);
      localStorage.removeItem(USER_COLOR_KEY);
      localStorage.removeItem(TIMESTAMP_KEY);
      alert("You have left the game.");
      location.reload(); // Reload to reset game state
    });

    function drawHand(id, username, hand, multiplicationCardDealt = false, folded = false) {
        if (!handDivs[id]) { // check if hand has ever been drawn since game start
            const div = document.createElement("div");
            div.className = "hand";
            div.id = "hand-" + id;
            document.body.appendChild(div);
            handDivs[id] = div;

            if (id === myId) {
                // make it a sortable for when we make the equations
                const sortableTemp = Sortable.create(div, {
                    animation: 150,
                    draggable: ".card",
                    disabled: true,
                    forceFallback: true
                });
                sortable = sortableTemp;
            }
        }

        if (multiplicationCardDealt) {
            alert("Multiplication card received. Please discard either addition, subtraction, or multiplication card.");
        }        

        // clear the hand, so we can redraw all cards on every deal
        handDivs[id].innerHTML = `<p></p>`; // injection
        const nameDiv = document.createElement("div");
        let nameDivContents = username;
        if (id === myId) {
            nameDivContents += ' (me)'; // injection
        }
        if (folded) {
            nameDivContents += ' (folded)'; // injection
        }
        nameDiv.innerHTML = '<p>' + nameDivContents + '</p>';
        nameDiv.className = "handLabel";
        nameDiv.id = "handLabel-" + id;
        if (folded) {
            nameDiv.classList.add("folded");
        }
        handDivs[id].appendChild(nameDiv);

        const playerChipsStacksContainerDiv = document.createElement("div");
        playerChipsStacksContainerDiv.className = "chip-stacks-container";
        playerChipsStacksContainerDiv.id = "chipStacksContainer-" + id;
        handDivs[id].appendChild(playerChipsStacksContainerDiv);
        
        hand.forEach((card, index) => {
            const cardDiv = document.createElement("div");
            
            let cardDivParagraph;

            if (card.value === OperatorCards.ROOT){
                // for roots, need to draw it by hand since font is bad
                const canvas = document.createElement('canvas');
                let scaleFactor;
                if (window.matchMedia("(max-width: 600px)").matches) {
                    // Mobile device canvas
                    scaleFactor = 3 / 10;
                } else {
                    // Larger device canvas
                    scaleFactor = 0.75;
                }
                
                canvas.width = scaleFactor * 120;
                canvas.height = scaleFactor * 180;

                canvas.id = `sqrt-canvas-${id}-${index}`;
                const ctx = canvas.getContext('2d');

                // draw root
                ctx.fillStyle = folded ? 'grey' : 'white';
                ctx.fillRect(0, 0, scaleFactor * 120, scaleFactor * 180);
                ctx.strokeStyle = 'black';
                ctx.lineWidth = scaleFactor * 14;
                ctx.lineCap = 'butt'; 
                ctx.beginPath();
                ctx.moveTo(scaleFactor * 20, scaleFactor * 98);
                ctx.lineTo(scaleFactor * 40, scaleFactor * 128);
                ctx.lineTo(scaleFactor * 70, scaleFactor * 48);
                ctx.lineTo(scaleFactor * 100, scaleFactor * 48);
                ctx.stroke();

                cardDiv.appendChild(canvas);
            } else {
                cardDivParagraph = document.createElement("p");
                if (card.value !== null) { // will be null in the case of hidden cards
                    cardDivParagraph.innerHTML = `${card.value}`;
                } // TODO injection
                cardDiv.appendChild(cardDivParagraph);
            }

            cardDiv.dataset.value = card.value; // for applyOps later
            cardDiv.className = card.value !== null ? "card" : "card-back"; // without null check, 0 becomes card-back since equivalent to false

            // careful with card and cardDiv naming like this
            if (card.value === NumberCards.TEN){
                if (window.matchMedia("(max-width: 600px)").matches) {
                    // Mobile device canvas
                    cardDivParagraph.style.letterSpacing = '-.1rem';
                    cardDivParagraph.style.transform = 'translateX(-0.2rem)';
                } else {
                    // Larger device canvas
                    cardDivParagraph.style.letterSpacing = '-1rem';
                    cardDivParagraph.style.transform = 'translateX(-0.7rem)';
                }
            }

            // is one of the three discardable operators
            if (
                card.value === OperatorCards.SUBTRACT ||
                card.value === OperatorCards.ADD ||
                card.value === OperatorCards.MULTIPLY
            ) {
                cardDivParagraph.dataset.value = card.value;

                if (multiplicationCardDealt) { // TODO this is also a mess. We should have a separate drawHighlights function
                    // learned: be careful with capitalization
                    cardDiv.className = "card card-highlighted"
                }
            }
            cardDiv.style.color = getColorFromSuit(card.suit);
            
            if (folded) { // do after card or card back. still want to show back even if greyed out
                cardDiv.classList.add("folded");
            }

            cardDiv.dataset.id = index;
            handDivs[id].appendChild(cardDiv);
        });
    }

    function notify(message) {
        let notificationDiv = document.getElementById("notificationDiv");
        notificationDiv.style.display = "block";
        notificationDiv.textContent = message;

        setTimeout(() => {
            hideNotificationDiv(); // this is actually wrong since we'll hide any other notifications coming in
            // we need to implement a queue or just have fewer notifications
        }, 1000);
    }
    function notifyThatAnotherPlayerIsBetting(name){
        let notificationDiv = document.getElementById("notificationDiv");
        notificationDiv.style.display = "block";
        notificationDiv.textContent = name + " is betting";
    }

    function beginCountdownNotification(){
        let notificationDiv = document.getElementById("notificationDiv");
        notificationDiv.style.display = "block";
        notificationDiv.textContent = "90";

        // begin countdown
        startTime = Date.now();
        endTime = startTime + totalDuration;
        updateTimer(); // only call once because it call requestAnimationFrame recursively
    }

    function hideNotificationDiv(){
        console.log("function hideNotificationDiv called");
        let notificationDiv = document.getElementById("notificationDiv");
        notificationDiv.style.display = "none";
        notificationDiv.textContent = "";
    }

    function drawPlayer(id, color, username, hostId) {
        let lobbyPlayerListContainer = document.getElementById("lobbyPlayerListContainer");
        const div = document.createElement("div");
        div.className = "lobbyPlayerListItem";
        div.innerHTML = `<p>👩‍💻 ${username}</p>` + (hostId === id ? ' (Host)' : '') + (id === myId ? ' (You)' : ''); // injection
        div.style.color = color;
        lobbyPlayerListContainer.appendChild(div);
    }

    function getColorFromSuit(suit) {
        switch(suit) {
            case Suits.GOLD:
                console.log(Suits.GOLD);
                return 'rgb(228, 167, 1)';
                break;
            case Suits.SILVER:
                console.log(Suits.SILVER);
                return 'rgb(177, 177, 177)';
                break;
            case Suits.BRONZE:
                console.log(Suits.BRONZE);
                return 'rgb(122, 61, 0)';
                break;
            case Suits.STONE:
                console.log(Suits.STONE);
                return 'rgb(66, 66, 66)';
                break;
        }
    }

    function setupBettingControls(toCall, maxBet, myChipCount) {
        const slider = document.getElementById("betSlider");
        const betLabel = document.getElementById("betAmountLabel");
        const callRaiseButton = document.getElementById("callRaiseButton");
        const allInButton = document.getElementById("allInButton");

        // Set slider range
        slider.min = toCall;
        slider.max = maxBet;
        slider.value = toCall;

        // Initial label
        betLabel.textContent = toCall + " to call";
        callRaiseButton.textContent = "Call";

        // Show controls
        document.getElementById("bettingControls").style.display = "block";

        slider.oninput = () => {
            const val = parseInt(slider.value);
            console.log(slider.min, slider.max, slider.value);
        
            betLabel.textContent = "Bet " + val + " (Raise " + (val - toCall);
            // what if currentBet is null
            callRaiseButton.textContent = val > toCall ? "Raise" : "Call";
        };

        allInButton.onclick = () => {
            slider.value = slider.max;
            slider.dispatchEvent(new Event("input")); // update UI
        };

        callRaiseButton.onclick = () => {
            const bet = parseInt(slider.value);
            console.log("Bet placed:", bet);
            socket.send(JSON.stringify({ type: "bet-placed", userId: myId, betAmount: bet, folded: false }));

            hideBettingControls();
        };

        document.getElementById("foldButton").onclick = () => {
            // send fold message. server will eliminate player and broadcast notification   
            console.log("Player folded, toCall is " + toCall);
            // need to send betAmount so that it doesn't get reset. refactor to track on server side
            socket.send(JSON.stringify({ type: "bet-placed", userId: myId, betAmount: toCall, folded: true }));
            hideBettingControls();
        };
    }

    function hideBettingControls() {
        document.getElementById("bettingControls").style.display = "none";
    }

    const maxStackSize = 10;
    let chipCount = 0;

    function updateChipStack(newCount, containerToUpdate) {
        console.log("updateChipStack called: " + newCount + " " + containerToUpdate);
        chipCount = newCount;

        // Clear all previous stacks and any previous overlay
        containerToUpdate.innerHTML = "";

        // Create and add the overlay for total chip count
        const overlay = document.createElement("div");
        overlay.classList.add("chip-count-overlay");
        overlay.textContent = chipCount;
        containerToUpdate.appendChild(overlay);

        const fullStacks = Math.floor(chipCount / maxStackSize);
        const remainder = chipCount % maxStackSize;

        const stackCounts = Array(fullStacks).fill(maxStackSize);
        if (remainder > 0) {
            stackCounts.push(remainder);
        }

        for (const count of stackCounts) {
            const stack = document.createElement("div");
            stack.classList.add("chip-stack");

            for (let i = 0; i < count; i++) {
                const chip = document.createElement("div");
                chip.classList.add("chip");
                stack.appendChild(chip);
            }

            containerToUpdate.appendChild(stack);
        }
    }

    // TODO use this timeout code when first going to the site. It's a cool animation to draw people in
    // setTimeout(() => updateChipStack(8), 3000);   // fewer chips
    // setTimeout(() => updateChipStack(17), 6000);  // mixed stack sizes

    // for now, just trust the client. eventually we'll have to send "card order" because even esnding the hand
    // is untrustable. and then the server can order the cards and apply operators
    function applyOps(cardElements) {
        const tokens = [];

        // Convert each card <div> into a token (number or operator)
        for (const card of cardElements) {
            const value = card.dataset.value;
            if (!value) continue;

            const val = value.trim();

            if (!isNaN(val)) {
                tokens.push(Number(val));
            } else if (val === '√') {
                tokens.push('sqrt'); // use keyword for safe eval later
            } else if (val === '+') {
                tokens.push('+');
            } else if (val === '-' || val === '−') {
                tokens.push('-');
            } else if (val === '÷' || val === '/') {
                tokens.push('/');
            } else if (val === '*' || val === '×') {
                tokens.push('*');
            } else {
                console.warn('Unhandled token:', val);
            }
        }

        console.log(tokens);
        // Convert tokens into evaluable expression string
        const expr = [];
        for (let i = 0; i < tokens.length; i++) {
            const tok = tokens[i];

            if (tok === 'sqrt') {
                // Check next token is a number
                const next = tokens[i + 1];
                if (typeof next === 'number') {
                    expr.push(`Math.sqrt(${next})`);
                    i++; // skip next token
                } else {
                    throw new Error("√ must be followed by a number");
                }
            } else {
                expr.push(tok);
            }
        }

        // Join into string and evaluate
        const exprStr = expr.join(' ');
        try {
            const result = Function(`"use strict"; return (${exprStr})`)();
            return result;
        } catch (e) {
            console.error("Invalid expression:", exprStr);
            throw e;
        }
    }

    let selectedChoices = new Set();

    function openChoiceModal(onConfirm) {
        const modal = document.getElementById('choiceModal');
        const options = modal.querySelectorAll('.option');
        selectedChoices.clear();
        options.forEach(opt => opt.classList.remove('selected'));

        modal.classList.remove('hidden');

        options.forEach(opt => {
            opt.onclick = () => {
            const choice = opt.dataset.choice;
            if (selectedChoices.has(choice)) {
                selectedChoices.delete(choice);
                opt.classList.remove('selected');
            } else {
                selectedChoices.add(choice);
                opt.classList.add('selected');
            }
            };
        });

        document.getElementById('confirmChoice').onclick = () => {
            modal.classList.add('hidden');
            onConfirm(Array.from(selectedChoices));
        };

        // document.getElementById('cancelChoice').onclick = () => {
        //     modal.classList.add('hidden');
        //     onConfirm(null);
        // };
    }

    function displayHandResults(msg) {
        const confirmResults = document.getElementById('confirmResults');

        confirmResults.classList.remove('hidden');

        msg.results.forEach(result => {
            if (result.isHiWinner) {
                let nameDiv = document.getElementById("handLabel-" + result.id);
                nameDiv.classList.add("hi-winner");

                // TODO redraw by indexOf currentHighestPlayersHighestCard
            }

            if (result.isLoWinner) {
                let nameDiv = document.getElementById("handLabel-" + result.id);
                nameDiv.classList.add("lo-winner");
                // TODO redraw by indexOf currentLowestPlayersLowestCard

            }
            const cardDiv = document.createElement("div");
            
            let cardDivParagraph = document.createElement("p");
            cardDivParagraph.innerHTML = "=" + formatNumber(result.result);
            cardDiv.appendChild(cardDivParagraph);

            cardDiv.className = "card"; // without null check, 0 becomes card-back since equivalent to false
            cardDiv.classList.add("result-card"); // without null check, 0 becomes card-back since equivalent to false

            if (result.result >= 10){ // TODO this is different for the refactor
                if (window.matchMedia("(max-width: 600px)").matches) {
                    // Mobile device canvas
                    cardDivParagraph.style.letterSpacing = '-.1rem';
                } else {
                    // Larger device canvas
                    cardDivParagraph.style.letterSpacing = '-1rem';
                }
                cardDivParagraph.style.transform = 'translateX(-0.7rem)';
            }

            cardDiv.style.color = "black";

            handDivs[result.id].appendChild(cardDiv);

            // starts over here. TODO don't duplicate code
            const differenceCardDiv = document.createElement("div");

            let differenceCardDivParagraph = document.createElement("p");
            differenceCardDivParagraph.innerHTML = "(" + formatNumber(result.difference) + ")";
            differenceCardDiv.appendChild(differenceCardDivParagraph);

            differenceCardDiv.className = "card"; // without null check, 0 becomes card-back since equivalent to false
            differenceCardDiv.classList.add("difference-card"); // without null check, 0 becomes card-back since equivalent to false

            if (result.difference >= 10){ // TODO this is different for the refactor
                if (window.matchMedia("(max-width: 600px)").matches) {
                    // Mobile device canvas
                    differenceCardDivParagraph.style.letterSpacing = '-.1rem';
                } else {
                    // Larger device canvas
                    differenceCardDivParagraph.style.letterSpacing = '-1rem';
                }
                differenceCardDivParagraph.style.transform = 'translateX(-0.7rem)';
            }

            differenceCardDiv.style.color = "red";

            handDivs[result.id].appendChild(differenceCardDiv);
        })
        
        document.getElementById('confirmResults').onclick = () => {
            socket.send(JSON.stringify({ type: "acknowledge-results", userId: myId }));
            confirmResults.classList.add('hidden');
        };
    }

function formatNumber(num, decimals = 2) {
    if (Number.isInteger(num)) {
        return num.toString();
    }
    return parseFloat(num.toFixed(decimals)).toString();
}
</script>
</body>
</html>