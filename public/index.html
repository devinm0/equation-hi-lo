<!DOCTYPE html>
<html lang="en">
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta charset="UTF-8" />
    <title>Equation Hi Lo</title>
    <link rel="icon" type="image/png" href="favicon.png" >
    <link rel="shortcut icon" href="favicon.png">
    <link rel="stylesheet" href="style.css">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8735848760963536"
        crossorigin="anonymous"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Uchen&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Zen+Old+Mincho&display=swap" rel="stylesheet">
    </head>
<body>
    <div id="choiceModal" class="modal-overlay hidden">
        <div class="modal">
            <h2>Select Hi, Lo, or Swing Betting</h2>
            <div class="options">
                <div class="option" data-choice="low">
                    <div class="low-symbol">1</div>
                    <p>Low</p>
                </div>
                <div class="option" data-choice="high">
                    <div class="high-symbol"><span class="high-symbol-span">20</span></div>
                    <p>High</p>
                </div>
            </div>
            <div class="buttons">
                <button id="confirmChoice" disabled>Confirm</button>
            </div>
        </div>
    </div>

    <div id="progressBarWrapper" style="display: none;">
        <div id="progressBar" style="display: none;"></div>
        <div id="progressBarOverlay" style="display: none;"></div>
    </div>

    <div id="notifications"></div>

    <div id="homeContainer"> <!--TODO rename to uiContainer-->
        <div id="homeTitleContainer">Equation <span style="white-space: nowrap;">Hi Lo</span></div>
        <p id="roomCodeInfo" style="color: white; text-align: center;">Got a room code? Enter here to join an existing game:</p>
        <div id="roomCodeInputContainer">
            <input type="text" id="roomCodeInput" placeholder="Room Code" pattern="^[a-zA-Z0-9]{4}$" required title="Room code does not exist. Room code consists of 4 letters or numbers"/>
            <p id="roomCodeError" style="color: rgb(255, 128, 128);"></p>
            <button id="enterRoomButton">Join Existing Game</button> <!--TODO change other join button name?-->
        </div>
        <p id="createRoomInfo" style="color: white;">Otherwise, host a new game here:</p>
        <button class="button" id="createButton">Create Private Game</button>
    </div>

    <div id="uiContainer" class="hidden"> <!--TODO rename to lobbyContainer-->
        <div id="lobbyTitleContainer">Equation <span style="white-space: nowrap;">Hi Lo</span></div>
        <div id="roomCodeContainer">Room Code:</div>
        <div id="lobbyPlayerListContainer"></div>
        <div id="nameContainer">
            <input type="text" id="nameInput" placeholder="Enter your name" pattern="^[a-zA-Z0-9]{1,12}$" required title="Username consists of 1-12 letters or numbers"/>
            <p id="nameError" style="color: rgb(255, 128, 128);"></p>
            <button id="submitNameButton">Submit Name</button>
        </div>
        <button class="button" id="startButton" style="display:none;" disabled>Start Game</button>
    </div>

    <div id="potContainer" style="width:100%; min-height: 90px;">
        <div id="potDiv" style="text-align: center; font-weight: bold; margin-bottom: 10px;"></div>

        <div id="potChipStacksContainer" class="chip-stacks-container" style="width: 100%"></div>
    </div>

    <div id="bettingControls" style="display:none;">
        <div id="chipStagingContainer" style="text-align:center; font-weight: bold; color: white;"><span id="betAmountLabel">0</span></div>
        <div id="betContainer">
            <button class="button" id="foldButton">Fold</button>
                <span id="sliderMin" style="color:white">0</span>
                <input type="range" min="0" max="1000" value="0" id="betSlider">
                <span id="sliderMax" style="color:white">1000</span>
            <button class="button" id="callRaiseButton">Call</button>
            <button class="button" id="allInButton">All In</button>
        </div>
    </div>

    <button id="confirmResults" class="hidden">Next Hand ‚úÖ</button>
    <button id="confirmEquationFormed" class="hidden">Lock in Equation ‚úÖ</button>
    <button id="confirmOtherEquationFormed" class="hidden">Lock in Second Equation ‚úÖ</button>

    <button class="button" id="leaveButton" style="display:none;">Leave Game</button>
    <script src="./sortable.js"></script>
    <script type="module">
    
    import { NumberCard, OperatorCard, Suit, GamePhase } from './enums.js';
    import { SoundManager } from './sounds.js';
    import CountdownTimer from "./timer.js";
        
    const progressBar = document.getElementById("progressBar");
    const progressBarOverlay = document.getElementById("progressBarOverlay");

    const timer = new CountdownTimer(90 * 1000, progressBar, progressBarOverlay);
    const sounds = new SoundManager();

    const socket = new WebSocket(`wss://equationhi.lol`);
    const handDivs = new Map(); // map of divs, one for each player
    const handDivsList = []; // ordered list of divs, so that we can draw the user's hand last
    const lobbyPlayerDivs = {}; // list of nametags basically, for game lobby. one per player

    const EXPIRATION_TIME = 1000 * 60 * 60 * 24;  // 1 day in milliseconds
    const USER_ID_KEY = 'userId';
    const USER_NAME_KEY = 'userName';
    const USER_COLOR_KEY = 'userColor';
    const TIMESTAMP_KEY = 'timestamp';

    let myId = localStorage.getItem(USER_ID_KEY);
    let myColor = localStorage.getItem(USER_COLOR_KEY);
    let myName = localStorage.getItem(USER_NAME_KEY);
    let timestamp = localStorage.getItem(TIMESTAMP_KEY);
    let myHand = null; // TODO this needs to be a serialized object
    let sortable = null; // allows for rearranging our hand to form the equation
    let numPlayersJoined = 0;

    socket.addEventListener("message", (event) => {
      const msg = JSON.parse(event.data);

      switch (msg.type) {
        case "init": {
            const now = Date.now();

            // TODO just refactor to if (playerDataStoredLocally() )
            console.log("myId is: ", myId, timestamp, " server message is: ", event.data, " So if the userIds don't match, it means we've rejoined. Discarding the server generated id.");
            if (!myId || !timestamp || now - timestamp > EXPIRATION_TIME) { // nothing in localStorage, means we are new, fill in with server generated user data
                myId = msg.id;
                myColor = msg.color;
                localStorage.setItem(USER_ID_KEY, myId);
                localStorage.setItem(USER_COLOR_KEY, myColor);
                localStorage.setItem(TIMESTAMP_KEY, now);
            } else { // items exist in localStorage = we exist = page refreshed
                // send rejoin socket message

                // if client never joined a game, just show regular page again.
                // if they did, show option to join that room again
                // should I implement uri for room code?
                const data = {
                    type: "refresh", // TODO need to change... refreshing page is no longer a join, take me to home page
                    userId: myId,
                    color: myColor,
                    username: myName
                };
                socket.send(JSON.stringify(data));
            }

            break;
        } 
        
        case "game-started": {
            const roomCode = document.getElementById("roomCodeContainer");
            if (window.matchMedia("(max-width: 800px)").matches) {
                roomCode.style.transform = "translate(calc(50vw - 50% - 10px), calc(-50vh + 50% + 30px))";
            } else {
                roomCode.style.transform = "translate(calc(50vw - 50% - 60px), calc(-50vh + 50% + 30px))";
            }

            const btn = document.getElementById("startButton");
            btn.parentNode.removeChild(btn);
            // document.getElementById("leaveButton").style.display = "block";
            document.getElementById("lobbyPlayerListContainer").remove();
            document.getElementById("lobbyTitleContainer").remove();
            showNotification('The game has started!');

            break;
        } 
        
        case "reject-start": {
            showNotification("At least 2 players must join before starting the game.");

            break;
        } 
        
        case "suggest-room": {
            document.getElementById("roomCodeInfo").textContent = "Rejoin game in progress:";
            document.getElementById("roomCodeInput").value = msg.roomCode;
            document.getElementById("enterRoomButton").textContent = "Rejoin Game";
            document.getElementById("createButton").style.display = "none";
            document.getElementById("createRoomInfo").style.display = "none";

            break;
        }

        case "begin-hand": {
            showPlayingLayout();
            showNotification("Beginning hand " + (msg.handNumber + 1));
 
            break;
       } 
        
        case "deal": {
            sounds.play("deal");

            console.log(msg);
            if (msg.id === myId) {
                myHand = msg.hand;
            }        
            drawHand(msg.id, msg.username, msg.hand, msg.multiplicationCardDealt);
        
            if (msg.chipCount !== undefined) {
                // this should be msg.id I guess. originally I was only using the deal message for myself
                updateChipStack(msg.chipCount, document.getElementById("chipStacksContainer-" + msg.id));
            }
            // TODO 5/20
            // need the same bool to only do this with alert.
            const highlightedCards = document.querySelectorAll('.card-highlighted');
            highlightedCards.forEach(card => {
                // have a guard clause here but might be better to KNOW that I'll only call this once
                if (!card.classList.contains('listener-added')) {
                    card.addEventListener('click', function() {
                        console.log('sending a discard message ');
                        console.log(this);
                        const data = {
                            type: "discard",
                            userId: myId,
                            value: this.children[0].dataset.value,
                            color: myColor,
                            username: myName
                        };
                        socket.send(JSON.stringify(data));
                        // remove the highlight from ALL cards
                        document.querySelectorAll('.card-highlighted').forEach(card => {
                            card.classList.remove("card-highlighted");// only do this once server confirms??
                        });
                    });

                    card.classList.add('listener-added');
                }
            });
  
            break;
        } 
        
        case "player-joined": {
            console.log("player-joined");
            drawPlayer(msg.id, msg.color, msg.username, msg.hostId);

            numPlayersJoined += 1;

            if (numPlayersJoined >= 2 && msg.hostId === myId) {
                // we are the Host, and there's at least one other player, so game can be started
                document.getElementById("startButton").disabled = false;            
            }
  
            break;
        } 
        
        case "player-discarded": {
            sounds.play("discard");

            if (msg.id === myId) {
                showNotification("You discarded your " + msg.value + " card.");
            } else {
                showNotification(msg.username + " discarded their " + msg.value + " card.");
            }
              
            break;
        } 
        
        case "first-round-betting-commenced": {
            console.log("First round betting commenced.");
            showNotification("First round betting has commenced.");  

            break;
        } 
        
        case "second-round-betting-commenced": {
            showNotification("Second round betting has commenced.");
            break;
        } 
        
        case "second-round-betting-skipped": {
            showNotification("1 or more players are all in. Second round betting skipped.");
  
            break;
        } 
        
        case "player-folded": {
            sounds.play("fold");

            showNotification(msg.username + " folded.");

            // const hand = handDivs.get(myId).querySelectorAll('.card');
            // console.log(hand);

            // for (const card of hand) {
            //     card.classList.add("folded");
            // };

            // console.log(Date.now());

            // setTimeout(() => {
            //     console.log("timeout complete");

            //     console.log(Date.now());

                drawHand(msg.id, msg.username, msg.hand, false, true);
            // }, 50 * hand.length + 300 );
  
            break;
        } 
        
        case "player-formed-equation": {
            // no new cards are dealt, so we need this special message to make everyone redraw the reordered hands 
            drawHand(msg.id, msg.username, msg.hand, false, false); 

            break;
        } 
        
        case "bet-placed": {
            console.log("socket message bet-placed");
            sounds.play(msg.betType);

            showNotification(msg.username + " bet " + msg.betAmount);
            updateChipStack(msg.chipCount, document.getElementById("chipStacksContainer-" + msg.id));

            updatePot(msg.pot);

            break;
        } 
        
        case "next-turn": {
            console.log("socket message next-turn");
            // document.getElementById("potDiv").textContent = "Pot: " + msg.pot;
            // updateChipStack(msg.pot, document.getElementById("chipStacksContainer"));
            // console.log(msg.currentTurnPlayerId, myId, msg.toCall);

            if (msg.currentTurnPlayerId === myId) { // bad practice. trusting the client to do this.
                setupBettingControls(msg.toCall, msg.maxBet, msg.playerChipCount);
                console.log("calling hideProgressBar from here");
                hideProgressBar();
            } else {
                notifyThatAnotherPlayerIsBetting(msg.username);
            }

            highlightCurrentBettingPlayerAndDehighlightOthers(msg.currentTurnPlayerId);
            // chips move from your stack to a staging stack
  
            break;
        } 
        
        case "end-betting-round": {
            // remove highlights from who is betting
            document.querySelectorAll(".handLabel").forEach(el => {
                el.style.backgroundColor = "";
            });

            console.log("socket message end-betting-round");
            if (msg.round === GamePhase.FIRSTBETTING){
                showNotification('First betting round complete. Dealing last open card');
            } else if (msg.round === GamePhase.SECONDBETTING) {
                showNotification('Second betting round complete.');
            }
            // TODO test that a folded player gets the right message once equation forming starts
  
            break;
        } 
        
        case "commence-equation-forming": {
            sounds.play("start");

            const confirmEquationFormedButton = document.getElementById("confirmEquationFormed");
            confirmEquationFormedButton.classList.remove("hidden");
            confirmEquationFormedButton.onclick = () => {
                let equationResult;
                const cards = handDivs.get(myId).querySelectorAll('.card');
                try {
                    equationResult = applyOps(cards);
                    console.log(equationResult);
                } catch (e) {
                    cards.forEach(card => {
                        card.classList.remove('blink-red');

                        card.classList.add('blink-red');

                        setTimeout(() => {
                            card.classList.remove('blink-red');
                        }, 1200)
                    });

                    showNotification("Malformed equation, try again.", "red", 5000);
                    return;
                }
                submitEquation(equationResult);
                confirmEquationFormedButton.classList.add('hidden');
            };

            console.log("socket message commence-equation-forming");
            beginCountdownNotification();
            if (msg.folded) {
                showNotification('Other players are forming their equations.');
            } else {
            showNotification('90 seconds! Drag cards to get close to 1 or 20.', "limegreen", 3000);
            sortable.option("disabled", false)
            }

            break;
        } 
        
        case "request-formed-equation": {
            showNotification('Time is up!');

            let equationResult;
            try {
                equationResult = applyOps(handDivs.get(myId).querySelectorAll('.card'));
                console.log("265 equationResult " + equationResult);
            } catch (e) {
                // bug here. if we sent a good equation early, but then custom send a client message with bad equation, now we fold. server doesn't check for that
                // i guess it means we should be doing the applyOps on the server side anyway
                showNotification("You were unable to form an equation. You fold automatically.", "red", 5000);
                // actually don't even need to send anything here. server can just handle it
                socket.send(JSON.stringify({ type: "fold", manual: false }));
            }
            submitEquation(equationResult);
        }

        case "end-equation-forming": {
            sounds.play("end");

            hideProgressBar();

            document.getElementById("confirmEquationFormed").classList.add("hidden");

            console.log("socket message end-equation-forming");
            break;
        } 
        
        function submitEquation(equationResult) {
            sortable.option("disabled", true)

            console.log(Array.from(handDivs.get(myId).querySelectorAll('.card')).map(card => card.dataset.id));
            const data = {
                type: "equation-result",
                userId: myId,
                username: myName,
                result: equationResult,
                order: Array.from(handDivs.get(myId).querySelectorAll('.card')).map(card => card.dataset.id)
            };
            socket.send(JSON.stringify(data));
        }
        
        case "hi-lo-selection": {
            showNotification("Select Hi, Lo, or Swing betting.");

            openChoiceModal(choices => {
                if (choices) {
                    if (choices.includes("high") && choices.includes("low")) {
                        sortable.option("disabled", false);
                        const confirmOtherEquationFormedButton = document.getElementById("confirmOtherEquationFormed");
                        confirmOtherEquationFormedButton.classList.remove("hidden");

                        confirmOtherEquationFormedButton.onclick = () => {
                            let equationResult;
                            const cards = handDivs.get(myId).querySelectorAll('.card');
                            try {
                                equationResult = applyOps(cards);
                                console.log(equationResult);
                            } catch (e) {
                                cards.forEach(card => {
                                    card.classList.remove('blink-red');

                                    card.classList.add('blink-red');

                                    setTimeout(() => {
                                        card.classList.remove('blink-red');
                                    }, 1200)
                                });

                                showNotification("Malformed equation, try again.", "red", 5000);
                                return;
                            }
                            
                            const data = {
                                type: "hi-lo-selected",
                                userId: myId,
                                username: myName,
                                choices: choices,
                                otherEquationResult: equationResult,
                                order: Array.from(handDivs.get(myId).querySelectorAll('.card')).map(card => card.dataset.id)
                            };
                            console.log(data);
                            socket.send(JSON.stringify(data));

                            console.log('Player chose:', choices); // e.g., ["low", "high"]

                            confirmOtherEquationFormedButton.classList.add('hidden');
                        };

                    } else {
                    // if both, enable sortable and hide modal, show lock in equation button
                        const data = {
                            type: "hi-lo-selected",
                            userId: myId,
                            username: myName,
                            choices: choices
                        };
                        console.log(data);
                        socket.send(JSON.stringify(data));

                        console.log('Player chose:', choices); // e.g., ["low", "high"]
                    }
                } else {
                    console.log('Player canceled');
                }
            });
  
            break;
        } 
        
       case "round-result": {
            if (msg.loWinner?.id === myId || msg.hiWinner?.id === myId) {
                sounds.play("win");
            }
            showNotification(msg.message, "limegreen", 10000);
            updatePot(0);

            // in the case of everyone but one folding, we don't need to show results. Same for everyone failing to form equation
            if (! msg.becauseAllButOneFolded && ! msg.becauseNoOneFormedEquation) {
                showResultsLayout(msg.loWinner?.id, msg.hiWinner?.id);
                displayHandResults(msg); 
            }
  
            break;
        } 
        
        case "room-join-reject": { // TODO rename to room-enter-reject
            const error = document.getElementById("roomCodeError");
            console.log("Room code does not exist.");
            error.textContent = "Room code does not exist.";
  
            break;
        } 
        
        case "room-entered": {
            document.getElementById("homeContainer").classList.add("hidden");
            document.getElementById("uiContainer").classList.remove("hidden");

            if (msg.joined) {
                document.getElementById("nameContainer").style.display = "none";
            }
            if (msg.inProgress) {
                document.getElementById("uiContainer").style.display = "none";
            }
            const roomCodeContainer = document.getElementById("roomCodeContainer");
            // TODO shouldn't trust client msg here.
            roomCodeContainer.textContent = "Room " + msg.roomCode;

            if (msg.hostId === myId) { 
                const startButton = document.getElementById("startButton")
                startButton.style.display = "block";
                startButton.disabled = true; // only enable it once the host joins
            }
  
            break;
        } 
        
        case "game-state": {

        }

        case "kicked": {
            if (msg.userId === myId) {
                showNotification("No more chips! You're out. Better luck next time!", "red");
            } else {
                //TODO redraw hand to be out (red and strikethrough)
                showNotification(msg.username + " has no more chips and is out of the game.", "red");
            }
  
            break;
        }
    }
});

    document.getElementById("submitNameButton").addEventListener("click", () => {
        const nameInput = document.getElementById("nameInput");
        const error = document.getElementById("nameError");

        console.log(error);
        const regex = /^[a-zA-Z0-9]{1,12}$/;

        if (!regex.test(nameInput.value)) {
            console.log("Must be 1-12 alphanumeric characters.");
            error.textContent = "Must be 1-12 alphanumeric characters.";
        } else {
            console.log("Name input value succeeds regex validation.");

            error.textContent = "";
        
            myName = nameInput.value; //.trim();
            localStorage.setItem('userName', myName);

            const data = {
                type: "join",
                color: myColor,
                userId: myId,
                username: myName
            };
            socket.send(JSON.stringify(data));

            document.getElementById("nameContainer").style.display = "none";
        }
    });

    document.getElementById("enterRoomButton").addEventListener("click", () => { // TODO rename to enter room button?
        // if (myName === null || myName === undefined) { // server prevents username being set twice
            const roomCodeInput = document.getElementById("roomCodeInput");
            const error = document.getElementById("roomCodeError");

            console.log(error);
            const regex = /^[a-zA-Z0-9]{4}$/;

            if (!regex.test(roomCodeInput.value)) {
                console.log("Room code must be 4 alphanumeric characters.");
                error.textContent = "Room code must be 4 alphanumeric characters.";
            } else {
                console.log("Room code input value succeeds regex validation.");

                error.textContent = "";
            
                const data = {
                    type: "enter", // TODO probably need to change this
                    color: myColor,
                    userId: myId,
                    username: myName,
                    roomCode: roomCodeInput.value.toUpperCase()
                };
                socket.send(JSON.stringify(data));
            }
        // }

    });

    document.getElementById("createButton").addEventListener("click", () => {
        console.log("myId " + myId);

        socket.send(JSON.stringify({ type: "create", userId: myId, color: myColor }));

        // TODO actually don't do this. need to wait to see if we've actually entered a room.
        // also rename to showRoomPage();
        document.getElementById("homeContainer").classList.add("hidden");
        document.getElementById("uiContainer").classList.remove("hidden");
    });

    document.getElementById("startButton").addEventListener("click", () => {
        socket.send(JSON.stringify({ type: "start", userId: myId }));
    });

    document.getElementById('leaveButton').addEventListener('click', () => {
      localStorage.removeItem(USER_ID_KEY);
      localStorage.removeItem(USER_COLOR_KEY);
      localStorage.removeItem(TIMESTAMP_KEY);
      alert("You have left the game.");
      location.reload(); // Reload to reset game state
    });

    function drawHand(id, username, hand, multiplicationCardDealt = false, folded = false) {
        let isRightHand = false;

        if (!handDivs.has(id)) { // check if hand has ever been drawn since game start. basically that there is a holder.
            const div = document.createElement("div");
            div.className = "hand";
            div.id = "hand-" + id;
            document.body.appendChild(div);
            handDivs.set(id, div);
            
            if (id === myId) {
                // make it a sortable for when we make the equations
                const sortableTemp = Sortable.create(div, {
                    animation: 150,
                    draggable: ".card",
                    disabled: true,
                    forceFallback: true,
                    onEnd: function () {
                        const cards = Array.from(div.querySelectorAll('.card'));
                        
                        // Remove old blink class
                        cards.forEach(card => card.classList.remove('blink-red'));

                        for (let i = 0; i < cards.length - 1; i++) {
                            const current = cards[i].dataset.value;
                            const next = cards[i + 1].dataset.value;

                            if (current === '√∑' && next === '0') {
                                cards[i].classList.add('blink-red');
                                cards[i + 1].classList.add('blink-red');

                                // need to remove the class, or else it blinks again once we drag it
                                setTimeout(() => {
                                    cards[i].classList.remove('blink-red');
                                    cards[i + 1].classList.remove('blink-red');
                                }, 1200)

                                showNotification("Cannot divided by zero", "red");
                            }
                        }
                    }
                });
                sortable = sortableTemp;
            }
        }

        if (id === myId) {
            handDivs.get(id).classList.add("my-hand");
            // handDivsList.push(id); // my-hand doesn't even need to go in the list for now for determining even or odd (left or right margin)
        } else {
            handDivs.get(id).classList.add("small-hand");
            // insert into penultimate index
            // handDivsList.splice(handDivsList.length - 1, 0, id);
            handDivsList.push(id); // TODO this may be broken once we support removing players.
            // ^ push to a list. hands that aren't my hand need to be drawn in rows of 2.
            // so every odd index hand will have margin-right: auto
            if (handDivsList.indexOf(id) % 2 !== 0) {
                console.log("adding class righthand and setting isRightHand to true");
                handDivs.get(id).classList.add("righthand");
                isRightHand = true;
            }
        }

        if (multiplicationCardDealt) {
            if (id === myId) {
                showNotification("Multiplication card received. Please discard either addition, subtraction, or multiplication card.", "yellow", 10000);
            }
        }        

        const handLengthBeforeThisDeal = handDivs.get(id).querySelectorAll(".card, .card-back").length;
        // clear the hand, so we can redraw all cards on every deal
        handDivs.get(id).innerHTML = ``; // injection
        
        const playerInfoDiv = document.createElement("div");
        playerInfoDiv.className = "player-info";

        const nameDiv = document.createElement("div");
        nameDiv.className = "handLabel";
        nameDiv.id = "handLabel-" + id;
        if (folded) {
            nameDiv.classList.add("folded");
        }
        playerInfoDiv.appendChild(nameDiv);

        const playerChipsStacksContainerDiv = document.createElement("div");
        playerChipsStacksContainerDiv.className = "chip-stacks-container";
        playerChipsStacksContainerDiv.id = "chipStacksContainer-" + id;
        playerInfoDiv.appendChild(playerChipsStacksContainerDiv);

        handDivs.get(id).appendChild(playerInfoDiv);

        const trophyDiv = document.createElement("div");
        trophyDiv.id = "trophy-" + id;
        trophyDiv.className = "trophy";
        trophyDiv.classList.add("hidden");
        trophyDiv.textContent = "üëë";
        nameDiv.appendChild(trophyDiv); // TODO will need to put it at the beginning not the end

        // TODO create a span for the name and add it after
        const loOptionDiv = document.createElement("div");
        loOptionDiv.id = "low-symbol-" + id;
        loOptionDiv.className = "low-symbol";
        loOptionDiv.classList.add("hidden");
        loOptionDiv.classList.add("low-symbol-mini");
        loOptionDiv.textContent = 1;
        nameDiv.appendChild(loOptionDiv); // TODO will need to put it at the beginning not the end

        const hiOptionDiv = document.createElement("div");
        hiOptionDiv.id = "high-symbol-" + id;
        hiOptionDiv.className = "high-symbol";
        hiOptionDiv.classList.add("hidden");
        hiOptionDiv.classList.add("high-symbol-mini");

        // necessary so that "20" can appear straight instead of rotated with the high symbol
        const hiOptionSpan = document.createElement("span");
        hiOptionSpan.classList.add("high-symbol-span");
        hiOptionSpan.textContent = 20;
        hiOptionDiv.appendChild(hiOptionSpan);

        nameDiv.appendChild(hiOptionDiv); // TODO will need to put it at the beginning not the end

        const nameSpan = document.createElement("span");
        let nameSpanContents = username;
        if (id === myId) {
            nameSpanContents += ' (me)'; // injection
        }
        if (folded) {
            nameSpanContents += ' (folded)'; // injection
        }
        if (multiplicationCardDealt && id !== myId) {
            nameSpanContents += ' (discarding...)';
        }
        nameSpan.innerHTML = '<p>' + nameSpanContents + '</p>';
        nameDiv.appendChild(nameSpan);

        drawCards(handDivs.get(id), id, hand, folded, multiplicationCardDealt, handLengthBeforeThisDeal);
    }

    function drawCards(divToAppendTo, id, hand, folded, multiplicationCardDealt, handLengthBeforeThisDeal) {
        hand.forEach((card, index) => {
            const cardDiv = document.createElement("div");
            
            let cardDivParagraph;

            if (card.value === OperatorCard.ROOT){
                const canvas = drawRootSymbol(id, index, folded);
                cardDiv.appendChild(canvas);
            } else {
                cardDivParagraph = document.createElement("p");

                if (card.value !== null) { // will be null in the case of hidden cards
                    cardDivParagraph.innerHTML = `${card.value}`;
                } // TODO injection
                cardDiv.appendChild(cardDivParagraph);
            }

            cardDiv.dataset.value = card.value; // for applyOps later
            cardDiv.className = card.value !== null ? "card" : "card-back"; // without null check, 0 becomes card-back since equivalent to false

            if (folded && myId !== id) {
                // other player's folded cards should be grey and card-back (hidden)
                cardDiv.className = "card-back";
                cardDiv.classList.add("folded");
                cardDiv.style.setProperty('--delay', `${index*50}ms`); // so that folding bounce happens in a wave
            } else {
                if (folded) { // do after card or card back. still want to show back even if greyed out
                    cardDiv.classList.add("folded");
                }

                if (card.suit === 4) {
                    cardDiv.classList.add("operator-card");
                } else {
                    cardDiv.classList.add("number-card");
                }

                // careful with card and cardDiv naming like this
                if (card.value === NumberCard.TEN){
                    cardDivParagraph.classList.add('ten');
                } else if (card.suit !== Suit.OPERATOR) {
                    cardDivParagraph.classList.add('single-digit');
                }

                // is one of the three discardable operators
                if (
                    card.value === OperatorCard.SUBTRACT ||
                    card.value === OperatorCard.ADD ||
                    card.value === OperatorCard.MULTIPLY
                ) {
                    cardDivParagraph.dataset.value = card.value;

                    if (multiplicationCardDealt && id === myId) { // TODO this is also a mess. We should have a separate drawHighlights function
                        // learned: be careful with capitalization
                        cardDiv.classList.add("card-highlighted");
                    }
                }
                cardDiv.style.color = getColorFromSuit(card.suit);

                // for sorting later
                cardDiv.dataset.id = index;
            }

            if (card.hidden && card.value !== null) { // shadow on either my card, or others cards once revealed in resultsview
                cardDiv.classList.add('secret');
                // cardDiv.style.backgroundColor = 'lightgrey';
            }

            if (index >= handLengthBeforeThisDeal) {
                cardDiv.classList.add("new-card");

                setTimeout(() => {
                    cardDiv.classList.remove("new-card");
                }, 3000)
            }

            divToAppendTo.appendChild(cardDiv);
        });
    }

    function notifyThatAnotherPlayerIsBetting(name){
        showNotification(name + " is betting", "yellow");
    }

    function highlightCurrentBettingPlayerAndDehighlightOthers(currentTurnPlayerId){
        // highlight only the betting person's hand
        document.querySelectorAll(".handLabel p").forEach(el => {
            el.style.backgroundColor = "rgba(0,0,0,0.3)";
        });
        document.querySelectorAll(".handLabel").forEach(el => {
            el.classList.remove("card-bounce");
        });
        let handLabel = document.getElementById("handLabel-" + currentTurnPlayerId);
        handLabel.classList.add("card-bounce");
        let handLabelParagraph = handLabel.querySelectorAll("p").forEach(el => {
            el.style.backgroundColor = "rgb(230, 208, 15)";
        });
    }

    function beginCountdownNotification() {
        let progressBarWrapper = document.getElementById("progressBarWrapper");
        progressBarWrapper.style.display = "block";

        let progressBarOverlay = document.getElementById("progressBarOverlay");
        progressBarOverlay.style.display = "block";

        let progressBar = document.getElementById("progressBar");
        progressBar.style.display = "block";
        progressBar.style.width = "100%";

        timer.start(); // only call once because it call requestAnimationFrame recursively
    }

    function hideProgressBar(){
        let progressBarWrapper = document.getElementById("progressBarWrapper");
        progressBarWrapper.style.display = "none";

        let progressBarOverlay = document.getElementById("progressBarOverlay");
        progressBarOverlay.style.display = "none";
        progressBarOverlay.textContent = "";

        let progressBar = document.getElementById("progressBar");
        progressBar.style.display = "none";
    }

    function drawPlayer(id, color, username, hostId) {
        let lobbyPlayerListItem = document.getElementById("lobbyPlayerListItem-" + id);
        if (lobbyPlayerListItem !== null) {
            lobbyPlayerListItem.innerHTML = `<p>üë©‚Äçüíª ${username}</p>` + (hostId === id ? ' (Host)' : '') + (id === myId ? ' (You)' : ''); // injection
        } else {
            let lobbyPlayerListContainer = document.getElementById("lobbyPlayerListContainer");
            const div = document.createElement("div");
            div.id = "lobbyPlayerListItem-" + id;
            div.className = "lobbyPlayerListItem";
            div.innerHTML = `<p>üë©‚Äçüíª ${username}</p>` + (hostId === id ? ' (Host)' : '') + (id === myId ? ' (You)' : ''); // injection
            div.style.color = color;
            lobbyPlayerListContainer.appendChild(div);
        }
    }

    function hidePotDiv() {
        document.getElementById("potDiv").textContent = "";
        document.getElementById("potChipStacksContainer").innerHTML = "";
    }

    function updatePot(chipCount) {
        document.getElementById("potDiv").textContent = "Pot";
        updateChipStack(chipCount, document.getElementById("potChipStacksContainer")); //should rename it to potStacksContainer
    }

    function getColorFromSuit(suit) {
        switch(suit) {
            case Suit.GOLD:
                return 'rgb(232, 179, 64)';
                break;
            case Suit.SILVER:
                return 'rgb(170, 170, 170)';
                break;
            case Suit.BRONZE:
                return 'rgb(149, 90, 49)';
                break;
            case Suit.STONE:
                return 'rgb(101, 101, 101)';
                break;
        }
    }

    function setupBettingControls(toCall, maxBet, myChipCount) {
        const slider = document.getElementById("betSlider");
        const betLabel = document.getElementById("betAmountLabel");
        const callRaiseButton = document.getElementById("callRaiseButton");
        const allInButton = document.getElementById("allInButton");
        const sliderMin = document.getElementById("sliderMin");
        const sliderMax = document.getElementById("sliderMax");
        
        // Set slider range
        slider.min = toCall;
        slider.max = maxBet;
        slider.value = toCall;

        console.log('before' + maxBet);
        
        if (slider.min === slider.max) {
            console.log('hit');
            slider.style.display = "none";
            sliderMin.style.display = "none";
            sliderMax.style.display = "none";
        }

        // Initial label
        betLabel.textContent = toCall + " to call";
        sliderMin.textContent = toCall;
        sliderMax.textContent = maxBet;
        callRaiseButton.textContent = "Call";

        // Show controls
        document.getElementById("bettingControls").style.display = "block";

        slider.oninput = () => {
            const val = parseInt(slider.value);
            console.log(slider.min, slider.max, slider.value);
        
            betLabel.textContent = "Bet " + val + " (Raise " + (val - toCall) + ")";
            // what if currentBet is null
            callRaiseButton.textContent = val > toCall ? "Raise" : "Call";
        };

        allInButton.onclick = () => {
            slider.value = slider.max;
            slider.dispatchEvent(new Event("input")); // update UI
        };

        callRaiseButton.onclick = () => {
            const bet = parseInt(slider.value);

            console.log("Bet placed:", bet);
            socket.send(JSON.stringify({ type: "bet-placed", userId: myId, betAmount: bet }));

            hideBettingControls();
        };

        document.getElementById("foldButton").onclick = () => {
            // send fold message. server will eliminate player and broadcast notification   
            console.log("Player folded, toCall is " + toCall);
            // need to send betAmount so that it doesn't get reset. refactor to track on server side
            socket.send(JSON.stringify({ type: "fold", manual: true }));
            hideBettingControls();
        };
    }

    function hideBettingControls() {
        // we may have previously hidden the slider if max bet was equal to min bet
        document.getElementById("betSlider").style.display = "inline-block";
        document.getElementById("sliderMin").style.display = "inline-block";
        document.getElementById("sliderMax").style.display = "inline-block";

        document.getElementById("bettingControls").style.display = "none";
    }

    const maxStackSize = 10;
    let chipCount = 0;

    function updateChipStack(newCount, containerToUpdate, differential) {
        chipCount = newCount;

        // Clear all previous stacks and any previous overlay
        containerToUpdate.innerHTML = "";

        // Create and add the overlay for total chip count
        const overlay = document.createElement("div");
        overlay.classList.add("chip-count-overlay");
        overlay.textContent = chipCount;

        const differentialSpan = document.createElement("span");
        differentialSpan.classList.add("differential-span");
        if (differential != null && differential > 0) {
            differentialSpan.textContent = " (+" + differential + ")";
        }
        overlay.appendChild(differentialSpan);
        containerToUpdate.appendChild(overlay);

        const fullStacks = Math.floor(chipCount / maxStackSize);
        const remainder = chipCount % maxStackSize;

        const stackCounts = Array(fullStacks).fill(maxStackSize);
        if (remainder > 0) {
            stackCounts.push(remainder);
        }

        for (const count of stackCounts) {
            const stack = document.createElement("div");
            stack.classList.add("chip-stack");

            for (let i = 0; i < count; i++) {
                const chip = document.createElement("div");
                chip.classList.add("chip");
                stack.appendChild(chip);
            }

            containerToUpdate.appendChild(stack);
        }
    }

    // TODO use this timeout code when first going to the site. It's a cool animation to draw people in
    // setTimeout(() => updateChipStack(8), 3000);   // fewer chips
    // setTimeout(() => updateChipStack(17), 6000);  // mixed stack sizes

    // for now, just trust the client. eventually we'll have to send "card order" because even esnding the hand
    // is untrustable. and then the server can order the cards and apply operators
    function applyOps(cardElements) {
        const tokens = [];

        // Convert each card <div> into a token (number or operator)
        for (const card of cardElements) {
            const value = card.dataset.value;
            if (!value) continue;

            const val = value.trim();

            if (!isNaN(val)) {
                tokens.push(Number(val));
            } else if (val === '‚àö') {
                tokens.push('sqrt'); // use keyword for safe eval later
            } else if (val === '+') {
                tokens.push('+');
            } else if (val === '-' || val === '‚àí') {
                tokens.push('-');
            } else if (val === '√∑' || val === '/') {
                tokens.push('/');
            } else if (val === '*' || val === '√ó') {
                tokens.push('*');
            } else {
                console.warn('Unhandled token:', val);
            }
        }

        console.log(tokens);
        // Convert tokens into evaluable expression string
        const expr = [];
        for (let i = 0; i < tokens.length; i++) {
            const tok = tokens[i];

            if (tok === 'sqrt') {
                // Check next token is a number
                const next = tokens[i + 1];
                if (typeof next === 'number') {
                    expr.push(`Math.sqrt(${next})`);
                    i++; // skip next token
                } else {
                    throw new Error("‚àö must be followed by a number");
                }
            } else {
                expr.push(tok);
            }
        }

        // Join into string and evaluate
        const exprStr = expr.join(' ');
        try {
            const result = Function(`"use strict"; return (${exprStr})`)();
            return result;
        } catch (e) {
            console.error("Invalid expression:", exprStr);
            throw e;
        }
    }

    let selectedChoices = new Set();

    function openChoiceModal(onConfirm) {
        const modal = document.getElementById('choiceModal');
        const options = modal.querySelectorAll('.option');
        const confirmButton = document.getElementById('confirmChoice');
        selectedChoices.clear();
        options.forEach(opt => opt.classList.remove('selected'));

        modal.classList.remove('hidden');

        options.forEach(opt => {
            opt.onclick = () => {
                sounds.play("hiloselect");

                const choice = opt.dataset.choice;
                if (selectedChoices.has(choice)) {
                    selectedChoices.delete(choice);
                    opt.classList.remove('selected');
                } else {
                    selectedChoices.add(choice);
                    opt.classList.add('selected');
                }

                if (selectedChoices.size > 0) {
                    confirmButton.disabled = false;
                } else {
                    confirmButton.disabled = true;
                }
            };
        });

        confirmButton.onclick = () => {
            modal.classList.add('hidden');
            onConfirm(Array.from(selectedChoices));
        };

        // document.getElementById('cancelChoice').onclick = () => {
        //     modal.classList.add('hidden');
        //     onConfirm(null);
        // };
    }

    // more test cases
    // made high hand first, selected lo then high
    // made high hand first, selected high then low
    // made low hand first, selected high then low
    // made low hand first, selected high then low
    function displayHandResults(msg) {
        const confirmResults = document.getElementById('confirmResults');

        confirmResults.classList.remove('hidden');

        msg.results.forEach(result => {
            console.log(result);
            updateChipStack(result.chipCount, document.getElementById("chipStacksContainer-" + result.id), result.chipDifferential);

            let nameDiv = document.getElementById("handLabel-" + result.id);
            console.log(nameDiv);
            let loOptionDiv = document.getElementById("low-symbol-" + result.id);
            let hiOptionDiv = document.getElementById("high-symbol-" + result.id);
            let trophyDiv = document.getElementById("trophy-" + result.id);
            const handDiv = handDivs.get(result.id);

            if (result.choices.includes("low")) {
                loOptionDiv.classList.remove("hidden");
            }
            if (result.choices.includes("high")) {
                hiOptionDiv.classList.remove("hidden");
            }
            if (result.isHiWinner) {
                trophyDiv.classList.remove("hidden");
                handDiv.classList.add("winner-div");
                // TODO redraw by indexOf hiWinnerHighCard
            }
            if (result.isLoWinner) {
                trophyDiv.classList.remove("hidden");
                handDiv.classList.add("winner-div");
                let nameDiv = document.getElementById("handLabel-" + result.id);
                // TODO redraw by indexOf currentLowestPlayersLowestCard

            }

            handDiv.querySelectorAll('.card').forEach(el => el.remove());

            if (result.choices.includes("low")) {
                drawCards(handDiv, result.id, result.lowHand, result.folded, false, result.lowHand?.length);

                const lowCardDiv = document.createElement("div");

                let lowCardDivResultParagraph = document.createElement("p");
                let lowCardDivDifferenceParagraph = document.createElement("p");

                lowCardDivResultParagraph.className = "result-paragraph"; // without null check, 0 becomes card-back since equivalent to false
                lowCardDivDifferenceParagraph.className = "difference-paragraph"; // without null check, 0 becomes card-back since equivalent to false

                lowCardDivResultParagraph.innerHTML = "=" + formatNumber(result.lowResult);
                lowCardDivDifferenceParagraph.innerHTML = "(" + formatNumber(result.lowDifference) + ")";

                lowCardDiv.appendChild(lowCardDivResultParagraph);
                lowCardDiv.appendChild(lowCardDivDifferenceParagraph);

                lowCardDiv.className = "card"; // without null check, 0 becomes card-back since equivalent to false
                lowCardDiv.classList.add("difference-card"); // without null check, 0 becomes card-back since equivalent to false

                // if (result.difference >= 10){ // TODO this is different for the refactor
                //     cardDivResultParagraph.style.transform = 'translateX(-0.7rem)';
                // }

                handDiv.appendChild(lowCardDiv);
            }

            // TODO was this for mobile!?
            // const lineBreakDiv = document.createElement("div");
            // lineBreakDiv.style.width = "100%";
            // handDiv.appendChild(lineBreakDiv);

            const otherEquationDiv = document.createElement("div");
            otherEquationDiv.style.display = "flex";
            otherEquationDiv.style.flex = "0 0 auto";
            handDiv.appendChild(otherEquationDiv);

            if (result.choices.includes("high")) {
                console.log(result.id, result.highHand, result.highHand.length);

                drawCards(otherEquationDiv, result.id, result.highHand, result.folded, false, result.highHand?.length);

                let nameDiv = document.getElementById("handLabel-" + result.id);
                console.log(nameDiv);
                
                const hiCardDiv = document.createElement("div");

                let hiCardDivResultParagraph = document.createElement("p");
                let hiCardDivDifferenceParagraph = document.createElement("p");

                hiCardDivResultParagraph.className = "result-paragraph"; // without null check, 0 becomes card-back since equivalent to false
                hiCardDivDifferenceParagraph.className = "difference-paragraph"; // without null check, 0 becomes card-back since equivalent to false

                console.log(result.highResult);
                hiCardDivResultParagraph.innerHTML = "=" + formatNumber(result.highResult);
                hiCardDivDifferenceParagraph.innerHTML = "(" + formatNumber(result.highDifference) + ")";

                hiCardDiv.appendChild(hiCardDivResultParagraph);
                hiCardDiv.appendChild(hiCardDivDifferenceParagraph);

                hiCardDiv.className = "card"; // without null check, 0 becomes card-back since equivalent to false
                hiCardDiv.classList.add("difference-card"); // without null check, 0 becomes card-back since equivalent to false

                // if (result.difference >= 10){ // TODO this is different for the refactor
                //     cardDivResultParagraph.style.transform = 'translateX(-0.7rem)';
                // }

                otherEquationDiv.appendChild(hiCardDiv);
            }

            // TODO add id for lowHand and highHand, cuz don't wanna highlight the low tiebreaker card inside the high hand or vice versa
            // and finally, highlight the tiebreaker card if there is one
            // TODO this logic won't work if the tiebreaker card is different value
            // need to check if equationResult is the same, AND THEN just highlight the lowest card
            // TODO it also won't work if one player has two cards of lowest value. in that case only
            //  show the lower suit which was their attempt at winning
            if (result.isLoContender) {
                const cards = Array.from(handDiv.querySelectorAll('.card'));
                for (let i = 0; i < cards.length - 1; i++) {
                    console.log(cards[i].dataset.value, result.lowCard);
                    if (Number(cards[i].dataset.value) === result.lowCard) {
                        cards[i].classList.add('card-highlighted');
                    }
                }
            }
            if (result.isHiContender) {
                const cards = Array.from(otherEquationDiv.querySelectorAll('.card'));
                for (let i = 0; i < cards.length - 1; i++) {
                    console.log(cards[i].dataset.value, result.highCard);
                    if (Number(cards[i].dataset.value) === result.highCard) {
                        cards[i].classList.add('card-highlighted');
                    }
                }
            }
        });
        
        document.getElementById('confirmResults').onclick = () => {
            socket.send(JSON.stringify({ type: "acknowledge-hand-results", userId: myId }));
            confirmResults.classList.add('hidden');
        };
    }

    function formatNumber(num, decimals = 2) {
        if (Number.isInteger(num)) {
            return num.toString();
        }
        return parseFloat(num.toFixed(decimals)).toString();
    }

    function showPlayingLayout() {
        const fullWidthHands = document.querySelectorAll('.full-width-hand');
        fullWidthHands.forEach(hand => {
            hand.classList.remove('full-width-hand')
        })

        const smallHands = document.querySelectorAll('.small-hand');
        smallHands.forEach(hand => {
            hand.classList.remove('small-hand')
        })

        const winningHands = document.querySelectorAll('.winner-div');
        smallHands.forEach(hand => {
            hand.classList.remove('winner-div');
        })

        // const winningHands = document.querySelectorAll('.winning-hand');
        // winningHands.forEach(hand => {
        //     hand.classList.remove('winning-hand')
        // })
    }

    function showResultsLayout(loWinner, hiWinner) {
        hidePotDiv();

        const rightHands = document.querySelectorAll('.righthand');
        rightHands.forEach(hand => {
            hand.classList.remove('righthand')
        })

        const myHand = document.querySelectorAll('.my-hand');
        myHand.forEach(hand => {
            hand.classList.remove('my-hand')
            hand.classList.add('small-hand')
        })

        const hands = document.querySelectorAll('.hand');
        hands.forEach(hand => {
            hand.classList.add('full-width-hand')
        })

        if (loWinner != null) {
            console.log("loWinner: " + loWinner);
            handDivs.get(loWinner).querySelectorAll(".card").forEach((card, index) => {
                card.classList.add('card-bounce');
                card.style.setProperty('--delay', `${index * 50}ms`);
            });
        }

        if (hiWinner != null) {
            console.log("hiWinner: " + hiWinner);
            handDivs.get(hiWinner).querySelectorAll(".card").forEach((card, index) => {
                card.classList.add('card-bounce');
                card.style.setProperty('--delay', `${index * 50}ms`);
            });
        }
    }

    function showNotification(message, color = "white", duration = 3000) {
        const container = document.getElementById('notifications');

        const note = document.createElement('div');
        note.className = 'notification';
        note.textContent = message;
        note.style.color = color;

        note.style.setProperty('--duration', `${duration}ms`);

        container.appendChild(note);

        // Remove after animation finishes
        setTimeout(() => {
            note.remove();
        }, duration + 300);
    }

    function drawRootSymbol(id, index, folded) {
        // for roots, need to draw it by hand since font is bad
        const canvas = document.createElement('canvas');
        let scaleFactor;
        if (window.matchMedia("(max-width: 800px)").matches) {
            // Mobile device canvas
            scaleFactor = 3 / 10;
        } else {
            // Larger device canvas
            scaleFactor = 0.75;
        }
        
        canvas.id = `sqrt-canvas-${id}-${index}`;
        const ctx = canvas.getContext('2d');

        const width = scaleFactor * 120;
        const height = scaleFactor * 180;
        const ratio = window.devicePixelRatio || 1;
        canvas.width = width * ratio;
        canvas.height = height * ratio;

        canvas.style.width = width + 'px'
        canvas.style.height = height + 'px'

        ctx.scale(ratio, ratio);

        // draw root
        ctx.fillStyle = folded ? 'lightgrey' : 'white';
        ctx.fillRect(0, 0, scaleFactor * 120, scaleFactor * 180);
        ctx.strokeStyle = 'rgb(40,40,40)';
        ctx.lineWidth = scaleFactor * 10;
        ctx.lineCap = 'butt'; 
        ctx.beginPath();
        ctx.moveTo(scaleFactor * 20, scaleFactor * 98);
        ctx.lineTo(scaleFactor * 40, scaleFactor * 128);
        ctx.lineTo(scaleFactor * 70, scaleFactor * 48);
        ctx.lineTo(scaleFactor * 100, scaleFactor * 48);
        ctx.stroke();

        return canvas;
    }
</script>
</body>
</html>