<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta charset="UTF-8" />
  <title>Equation Hi Lo</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
    <div id="notificationWrapper">
        <div id="notificationDiv" style="display: none;"></div>
    </div>

    <div id="uiContainer">
        <div id="lobbyPlayerListContainer"></div>
        <div id="nameContainer">
            <input type="text" id="nameInput" placeholder="Enter your name" />
            <button id="saveName">Join</button>
        </div>
        <button class="button" id="startBtn" style="display:none;" disabled>Start Game</button>
    </div>

    <div id="potDiv" style="text-align: center; font-weight: bold; margin-bottom: 10px;"></div>

    <div id="chipStacksContainer" class="chip-stacks-container"></div>

    <div id="bettingControls" style="display:none;">
        <div id="chipStagingContainer" style="text-align:center; font-weight: bold; color: white;"><span id="betAmountLabel">0</span></div>
        <div id="betContainer">
            <button class="button" id="foldButton">Fold</button>
            <input type="range" min="0" max="1000" value="0" id="betSlider">
            <button class="button" id="callRaiseButton">Call</button>
            <button class="button" id="allInButton">All In</button>
        </div>
        
    </div>

    <button class="button" id="leaveButton" style="display:none;">Leave Game</button>
  <script>
    const socket = new WebSocket(`ws://localhost:3000`);
    const handDivs = {};
    const lobbyPlayerDivs = {};

    const EXPIRATION_TIME = 1000 * 60 * 60 * 24;  // 1 day in milliseconds
    const USER_ID_KEY = 'userId';
    const USER_NAME_KEY = 'userName';
    const USER_COLOR_KEY = 'userColor';
    const TIMESTAMP_KEY = 'timestamp';

    let myId = localStorage.getItem(USER_ID_KEY);
    let myColor = localStorage.getItem(USER_COLOR_KEY);
    let myName = localStorage.getItem(USER_NAME_KEY);
    let timestamp = localStorage.getItem(TIMESTAMP_KEY);
    let myHand = null; // TODO this needs to be a serialized object

    //sounds like we are telling socket to listen but no we are listening to socket
    socket.addEventListener("message", (event) => {
      // what if it doesn't have all the fields?
      const msg = JSON.parse(event.data);

      // TODO don't send init message if an existing player is connecting?
      // for now, check if myId is not null and take the init message id if it is
      // this means the server is generating unneeded ids
      if (msg.type === "init") {
        const now = Date.now();

        console.log('init ' + myId);
        console.log(event.data);

        if (!myId || !timestamp || now - timestamp > EXPIRATION_TIME) {
            console.log('no stored token');
            myId = msg.id;
            myColor = msg.color;
            localStorage.setItem(USER_ID_KEY, myId);
            localStorage.setItem(USER_COLOR_KEY, myColor);
            localStorage.setItem(TIMESTAMP_KEY, now);
        }

        // need to change this
        if (msg.isHost) {
            const button = document.getElementById("startBtn")
            button.style.display = "block";
            button.disabled = true; // only enable it once the host joins
        }
      } else if (msg.type === "game-started") {
        const btn = document.getElementById("startBtn");
        btn.parentNode.removeChild(btn);
        document.getElementById("leaveButton").style.display = "block";
        document.getElementById("lobbyPlayerListContainer").remove();
        drawHand(msg.id, msg.username, msg.hand, true);
        updateChipStack(msg.chipCount, document.getElementById("chipStacksContainer-" + myId));
        alert("The game has started!");
      } else if (msg.type === "first-open-deal") {
        if (msg.id === myId) {
            myHand = msg.hand;
        }
        drawHand(msg.id, msg.username, msg.hand, true);
        updateChipStack(msg.chipCount, document.getElementById("chipStacksContainer-" + myId));

        // TODO 5/20
        // need the same bool to only do this with alert.
        const highlightedCards = document.querySelectorAll('.card-highlighted');
        highlightedCards.forEach(card => {
            // have a guard clause here but might be better to KNOW that I'll only call this once
            if (!card.classList.contains('listener-added')) {
                card.addEventListener('click', function() {
                    console.log('sending a discard message ');
                    console.log(this);
                    const data = {
                        type: "discard",
                        id: myId,
                        value: this.children[0].dataset.value,
                        color: myColor,
                        username: myName
                    };
                    socket.send(JSON.stringify(data));
                    // remove the highlight from ALL cards
                    document.querySelectorAll('.card-highlighted').forEach(card => {
                        card.classList.remove("card-highlighted");// only do this once server confirms??
                    });
                });

                card.classList.add('listener-added');
            }
        });
      } else if (msg.type === "deal") {
        if (msg.id === myId) {
            myHand = msg.hand;
        }
        drawHand(msg.id, msg.username, msg.hand);
      } else if (msg.type === "player-joined") {
        drawPlayer(msg.color, msg.username, msg.isHost);

        if (msg.isHost) {
            const button = document.getElementById("startBtn")
            button.disabled = false;            
        }
      } else if (msg.type === "player-discarded") {
        alert(msg.username + " discarded their " + msg.value + " card.");
      } else if (msg.type === "first-round-betting-commenced") {
        alert("First round betting has commenced.");
      } else if (msg.type === "bet-placed") {
        if (msg.folded) {
            alert(msg.username + " folded.");
        } else { 
            alert(msg.username + " bet " + msg.betAmount);
            updateChipStack(msg.chipCount, document.getElementById("chipStacksContainer-" + msg.id));

            // update pot
            document.getElementById("potDiv").textContent = "Pot: " + msg.pot;
            updateChipStack(msg.pot, document.getElementById("chipStacksContainer")); //should rename it to potStacksContainer
        }
      } else if (msg.type === "next-turn") {
        // document.getElementById("potDiv").textContent = "Pot: " + msg.pot;
        // updateChipStack(msg.pot, document.getElementById("chipStacksContainer"));
        console.log(msg.currentTurnPlayerId, myId, msg.toCall);

        if (msg.currentTurnPlayerId === myId) { // bad practice. trusting the client to do this.
            setupBettingControls(msg.toCall, msg.maxBet, msg.playerChipCount);
            hideNotificationDiv();
        } else {
            notifyThatAnotherPlayerIsBetting(msg.username);
        }
        // chips move from your stack to a staging stack
      }
    });

    document.getElementById("saveName").addEventListener("click", () => {
        if (myName !== undefined) { // server prevents username being set twice
            const nameInput = document.getElementById("nameInput");
            myName = nameInput.value; //.trim();
            localStorage.setItem('userName', myName);

            const data = {
                type: "join",
                color: myColor,
                userId: myId,
                username: myName
            };
            socket.send(JSON.stringify(data));
        }

        document.getElementById("nameContainer").style.display = "none";
    });

    document.getElementById("startBtn").addEventListener("click", () => {
        socket.send(JSON.stringify({ type: "start" }));
    });

    document.getElementById('leaveButton').addEventListener('click', () => {
      localStorage.removeItem(USER_ID_KEY);
      localStorage.removeItem(USER_COLOR_KEY);
      localStorage.removeItem(TIMESTAMP_KEY);
      alert("You have left the game.");
      location.reload(); // Reload to reset game state
    });

    function drawHand(id, username, hand, isFirstOpenDeal = false) {
        console.log("id in drawHand: " + id);
        if (!handDivs[id]) { // checks if we already drew it??? no. check if it's been drawn THE FIRST TIME
            const div = document.createElement("div");
            div.className = "hand";
            document.body.appendChild(div);
            handDivs[id] = div;
        }

        // Add check, don't assume server guarantees at most one multiply card
        const handContainsMultiplyCard = myHand.some(e => e.value === 'multiply');
        
        // TODO: bug we get a notification twice here
        // TODO: we get a  notification again if it wasn't the discard.
        //       need a bool that says we've notified.
        if (handContainsMultiplyCard && isFirstOpenDeal) {
            alert("Multiplication card received. Please discard either addition, subtraction, or multiplication card.");
        }        

        // clear the hand, since this gets drawn on every deal, so we can redraw the cards
        handDivs[id].innerHTML = `<p></p>`; // injection
        const nameDiv = document.createElement("div");
        nameDiv.innerHTML = `<p>${username}</p>`; // injection
        nameDiv.className = "handLabel";
        handDivs[id].appendChild(nameDiv);

        const playerChipsStacksContainerDiv = document.createElement("div");
        playerChipsStacksContainerDiv.className = "chip-stacks-container";
        playerChipsStacksContainerDiv.id = "chipStacksContainer-" + id;
        handDivs[id].appendChild(playerChipsStacksContainerDiv);
        
        hand.forEach((card) => {
            const cardDiv = document.createElement("div");
            const cardDivParagraph = document.createElement("p");
            cardDivParagraph.innerHTML = `${getTextFromCardValue(card.value)}`;
            cardDiv.appendChild(cardDivParagraph);
            cardDiv.className = card.value ? "card" : "card-back";

            // careful with card and cardDiv naming like this
            if (card.value === "TEN"){
                cardDivParagraph.style.letterSpacing = '-1rem';
                cardDivParagraph.style.transform = 'translateX(-0.7rem)';
            }
            if (
                card.value === "subtract" ||
                card.value === "add" ||
                card.value === "multiply"
            ) {
                cardDivParagraph.dataset.value = card.value;

                if (handContainsMultiplyCard && id === myId && isFirstOpenDeal) { // TODO this is also a mess. We should have a separate drawHighlights function
                    // learned: be careful with capitalization
                    cardDiv.className = "card card-highlighted"
                }
            }
            cardDiv.style.color = getColorFromSuit(card.suit);
            
            handDivs[id].appendChild(cardDiv);
        });
    }

    function notifyThatAnotherPlayerIsBetting(name){
        let notificationDiv = document.getElementById("notificationDiv");
        notificationDiv.style.display = "block";
        notificationDiv.textContent = name + " is betting";
    }

    function hideNotificationDiv(){
        let notificationDiv = document.getElementById("notificationDiv");
        notificationDiv.style.display = "none";
        notificationDiv.textContent = "";
    }

    function drawPlayer(color, username, isHost) {
        let lobbyPlayerListContainer = document.getElementById("lobbyPlayerListContainer");
        const div = document.createElement("div");
        div.className = "lobbyPlayerListItem";
        div.innerHTML = `<p>${username}</p>` + (isHost ? ' (Host)' : ''); // injection
        div.style.color = color;
        lobbyPlayerListContainer.appendChild(div);
    }

    function getColorFromSuit(suit) {
        switch(suit) {
            case 'GOLD':
                return 'rgb(228, 167, 1)';
                break;
            case 'SILVER':
                return 'rgb(177, 177, 177)';
                break;
            case 'BRONZE':
                return 'rgb(122, 61, 0)';
                break;
            case 'STONE':
                return 'rgb(66, 66, 66)';
                break;
        }
    }

    function getTextFromCardValue(value) {
        switch(value) {
            case 'TEN':
                return 10;
                break;
            case 'NINE':
                return 9;
                break;
            case 'EIGHT':
                return 8;
                break;
            case 'SEVEN':
                return 7;
                break;
            case 'SIX':
                return 6;
                break;
            case 'FIVE':
                return 5;
                break;
            case 'FOUR':
                return 4;
                break;
            case 'THREE':
                return 3;
                break;
            case 'TWO':
                return 2;
                break;
            case 'ONE':
                return 1;
                break;
            case 'ZERO':
                return 0;
                break;
            case 'ROOT':
                return 'v';
                break;
            case 'multiply': // TODO need to fix the enum, use enum values instead of strings
                return '&times';
                break;
            case 'divide':
                return '&divide';
                break;
            case 'subtract': // TODO should rename this to minus
                return '−';
                break;
            case 'add':
                return '+';
                break;
            default:
                return '';
        }
    }

    function setupBettingControls(toCall, maxBet, myChipCount) {
        const slider = document.getElementById("betSlider");
        const betLabel = document.getElementById("betAmountLabel");
        const callRaiseButton = document.getElementById("callRaiseButton");
        const allInButton = document.getElementById("allInButton");

        // Set slider range
        slider.min = toCall;
        slider.max = maxBet;
        slider.value = toCall;

        // Initial label
        betLabel.textContent = toCall + " to call";
        callRaiseButton.textContent = "Call";

        // Show controls
        document.getElementById("bettingControls").style.display = "block";

        slider.oninput = () => {
            const val = parseInt(slider.value);
            console.log(slider.min, slider.max, slider.value);
        
            betLabel.textContent = "Bet " + val + " (Raise " + (val - toCall);
            // what if currentBet is null
            callRaiseButton.textContent = val > toCall ? "Raise" : "Call";
        };

        allInButton.onclick = () => {
            slider.value = slider.max;
            slider.dispatchEvent(new Event("input")); // update UI
            // You may also trigger the bet here, if appropriate
        };

        callRaiseButton.onclick = () => {
            const bet = parseInt(slider.value);
            // TODO Emit or handle bet logic
            console.log("Bet placed:", bet);
            socket.send(JSON.stringify({ type: "bet-placed", userId: myId, betAmount: bet, folded: false }));

            hideBettingControls();
        };

        document.getElementById("foldButton").onclick = () => {
            // send fold message. server will eliminate player and broadcast notification   
            console.log("Player folded");
            socket.send(JSON.stringify({ type: "bet-placed", userId: myId, folded: true }));
        };
    }

    function hideBettingControls() {
        document.getElementById("bettingControls").style.display = "none";
    }

    const maxStackSize = 10;
    let chipCount = 0;

    function updateChipStack(newCount, containerToUpdate) {
        chipCount = newCount;
        
        // Clear all previous stacks
        containerToUpdate.innerHTML = "";

        const fullStacks = Math.floor(chipCount / maxStackSize);
        const remainder = chipCount % maxStackSize;

        const stackCounts = Array(fullStacks).fill(maxStackSize);
        if (remainder > 0) {
            stackCounts.push(remainder);
        }

        for (const count of stackCounts) {
            const stack = document.createElement("div");
            stack.classList.add("chip-stack");

            for (let i = 0; i < count; i++) {
                const chip = document.createElement("div");
                chip.classList.add("chip");
                stack.appendChild(chip);
            }

            containerToUpdate.appendChild(stack);
        }
    }

    // TODO use this timeout code when first going to the site. It's a cool animation to draw people in
    // setTimeout(() => updateChipStack(8), 3000);   // fewer chips
    // setTimeout(() => updateChipStack(17), 6000);  // mixed stack sizes

</script>
</body>
</html>